from __future__ import annotations

from typing import Any, Dict, List, Optional


def _safe_str(x: Any) -> str:
    return "" if x is None else str(x)


def _join_steps(steps: Any) -> str:
    if not steps:
        return "N/A"
    if isinstance(steps, list):
        return "\n".join([f"- {s}" for s in steps])
    return _safe_str(steps)


def _title_os(os_value: Any) -> str:
    """
    Normalize OS for nicer Jira formatting.
    Examples:
      "windows" -> "Windows"
      "mac" -> "Mac"
      "linux" -> "Linux"
      None/"" -> "Unknown OS"
    """
    raw = _safe_str(os_value).strip()
    if not raw:
        return "Unknown OS"

    low = raw.lower()
    if low in {"win", "windows", "win10", "win11"}:
        return "Windows"
    if low in {"mac", "macos", "osx", "os x"}:
        return "Mac"
    if low in {"linux", "ubuntu", "debian"}:
        return "Linux"

    # Fallback: Title Case each word
    return raw.title()


def build_vpn_incident_payload(
    *,
    session_id: str,
    handoff_summary: Dict[str, Any],
    project_key: str = "IT",
    issue_type: str = "Incident",
    reporter: Optional[str] = None,
    labels: Optional[List[str]] = None,  # ✅ NEW
) -> Dict[str, Any]:
    """
    Build a Jira 'create issue' payload (no API call here).

    Input expects the same structure you return as handoff_summary:
      {
        "category": "VPN_ISSUE",
        "state": "VPN_HANDOFF",
        "os": "windows",
        "client": "AnyConnect",
        "symptom": "disconnects",
        "error_code": "619",
        "attempt_count": 2,
        "steps_given": [...]
      }

    Output matches Jira REST API create-issue shape:
      {"fields": {...}}
    """

    os_name = _title_os(handoff_summary.get("os"))
    client = _safe_str(handoff_summary.get("client")).strip() or "Unknown client"
    symptom = _safe_str(handoff_summary.get("symptom")).strip() or "Unknown symptom"
    error_code = _safe_str(handoff_summary.get("error_code")).strip() or "No code"
    attempts = handoff_summary.get("attempt_count")
    steps_given = handoff_summary.get("steps_given")

    # Human-readable summary (short)
    summary = f"VPN issue - error {error_code} on {os_name} ({client})"

    # Structured description (good for IT / Jira triage)
    description_lines: List[str] = [
        "Automated handoff summary (generated by Chatbox Support Automation):",
        "",
        f"Session ID: {session_id}",
        f"Category: {_safe_str(handoff_summary.get('category'))}",
        f"Flow state: {_safe_str(handoff_summary.get('state'))}",
        "",
        "User environment:",
        f"- OS: {os_name}",
        f"- VPN client: {client}",
        f"- Symptom: {symptom}",
        f"- Error code/message: {error_code}",
        "",
        "Troubleshooting attempts:",
        f"- Attempt count: {_safe_str(attempts)}",
        "Steps given:",
        _join_steps(steps_given),
    ]

    fields: Dict[str, Any] = {
        "project": {"key": project_key},
        "issuetype": {"name": issue_type},
        "summary": summary,
        "description": "\n".join(description_lines),
    }

    # ✅ NEW: add labels only if provided (tenant-mapped)
    if labels:
        fields["labels"] = labels

    # Optional field example (only if you want it later)
    if reporter:
        fields["reporter"] = {"name": reporter}

    return {"fields": fields}


def build_generic_incident_payload(
    *,
    correlation_id: str,
    handoff_summary: Dict[str, Any],
    project_key: str = "IT",
    issue_type: str = "Incident",
    reporter: Optional[str] = None,
    labels: Optional[List[str]] = None,
) -> Dict[str, Any]:
    """
    Build a generic Jira 'create issue' payload for non-VPN categories
    (PASSWORD_RESET / EMAIL_ISSUE / GENERAL / UNKNOWN, etc.).

    Designed primarily for email ingestion Mode A.

    Expected minimal structure:
      {
        "category": "PASSWORD_RESET" | "EMAIL_ISSUE" | "GENERAL" | "UNKNOWN" | ...,
        "state": "EMAIL_INGEST",
        "email": {
          "message_id": "...",
          "from": "...",
          "to": "...",
          "subject": "..."
        },
        "body": "..."
      }
    """

    category = _safe_str(handoff_summary.get("category")).strip() or "GENERAL"
    state = _safe_str(handoff_summary.get("state")).strip() or "EMAIL_INGEST"

    email_obj = handoff_summary.get("email") or {}
    if not isinstance(email_obj, dict):
        email_obj = {}

    subject = _safe_str(email_obj.get("subject")).strip() or "No subject"
    from_email = _safe_str(email_obj.get("from")).strip() or "Unknown sender"
    to_email = _safe_str(email_obj.get("to")).strip() or "Unknown recipient"
    message_id = _safe_str(email_obj.get("message_id")).strip() or correlation_id

    body = _safe_str(handoff_summary.get("body")).strip()

    # Summary: keep short and consistent
    summary = f"{category}: {subject}"
    if len(summary) > 250:
        summary = summary[:247] + "..."

    # Description: structured, useful for triage
    description_lines: List[str] = [
        "Automated ticket created from inbound email (Chatbox Support Automation):",
        "",
        f"Correlation ID: {correlation_id}",
        f"Category: {category}",
        f"Flow state: {state}",
        "",
        "Email metadata:",
        f"- Message-ID: {message_id}",
        f"- From: {from_email}",
        f"- To: {to_email}",
        f"- Subject: {subject}",
        "",
        "Email body:",
        body or "N/A",
    ]

    fields: Dict[str, Any] = {
        "project": {"key": project_key},
        "issuetype": {"name": issue_type},
        "summary": summary,
        "description": "\n".join(description_lines),
    }

    if labels:
        fields["labels"] = labels

    if reporter:
        fields["reporter"] = {"name": reporter}

    return {"fields": fields}
